// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ForwardAdvectionXYZ
#pragma kernel BackwardAdvectionXYZ

#pragma kernel ForwardAdvectionX
#pragma kernel ForwardAdvectionY
#pragma kernel ForwardAdvectionZ

#pragma kernel BackwardAdvectionX
#pragma kernel BackwardAdvectionY
#pragma kernel BackwardAdvectionZ

#pragma kernel AdvectionCleanUp

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

RWTexture3D<half4> _WindTexturePrevFrame;

RWTexture3D<int> _WindTexturePrevX;
RWTexture3D<int> _WindTexturePrevY;
RWTexture3D<int> _WindTexturePrevZ;

RWTexture3D<int> _WindTexturePrevPrevX;
RWTexture3D<int> _WindTexturePrevPrevY;
RWTexture3D<int> _WindTexturePrevPrevZ;

uint3 _WindVolumeTextureSize;
// float _DeltaTime;
float _WindAttenuationStrength;
float _WindAdvectionIntensity;

#define MULTIPLIER 0.5f * _WindAttenuationStrength
#define FXDPT_SIZE (1 << 16) // negative 16, positive 16 => int32 texture

void AtomicAdd(uniform RWTexture3D<int> rwTex, uniform uint3 rwTexSize, in uint3 coord, in float value)
{
    if (all(coord < rwTexSize))
    {
        InterlockedAdd(rwTex[coord], (int)(value * FXDPT_SIZE));
    }
}

void AtomicAdd(uniform RWTexture3D<int> rwTex, uniform uint3 rwTexSize, in uint3 coord, in int value)
{
    if (all(coord < rwTexSize))
    {
        InterlockedAdd(rwTex[coord], value);
    }
}

float IntToFloat(int value)
{
    return (float)value / FXDPT_SIZE;
}

void CalculateWeights(inout float weights[8], float3 weight_floor, float3 weight_ceil)
{
    weights[0] = weight_floor.x * weight_floor.y * weight_floor.z;
    weights[1] = weight_floor.x * weight_floor.y * weight_ceil.z;
    weights[2] = weight_floor.x * weight_ceil.y * weight_floor.z;
    weights[3] = weight_floor.x * weight_ceil.y * weight_ceil.z;
    weights[4] = weight_ceil.x * weight_floor.y * weight_floor.z;
    weights[5] = weight_ceil.x * weight_floor.y * weight_ceil.z;
    weights[6] = weight_ceil.x * weight_ceil.y * weight_floor.z;
    weights[7] = weight_ceil.x * weight_ceil.y * weight_ceil.z;
}

void TrilinearForwardAdvection(uniform RWTexture3D<int> rwTex, uniform uint3 rwTexSize,
    uint3 coord_floor, uint3 coord_ceil, float weights[8], float one_axis_velocity)
{
    // floor, floor, floor
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_floor.x, coord_floor.y, coord_floor.z),
        weights[0] * one_axis_velocity * MULTIPLIER);
    
    // floor, floor, ceil
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_floor.x, coord_floor.y, coord_ceil.z),
        weights[1] * one_axis_velocity * MULTIPLIER);
    
    // floor, ceil, floor,
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_floor.x, coord_ceil.y, coord_floor.z),
        weights[2] * one_axis_velocity * MULTIPLIER);
    
    // floor, ceil, ceil
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_floor.x, coord_ceil.y, coord_ceil.z),
        weights[3] * one_axis_velocity * MULTIPLIER);
    
    // ceil, floor, floor
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_ceil.x, coord_floor.y, coord_floor.z),
        weights[4] * one_axis_velocity * MULTIPLIER);
    
    // ceil, floor, ceil
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_ceil.x, coord_floor.y, coord_ceil.z),
        weights[5] * one_axis_velocity * MULTIPLIER);
    
    // ceil, ceil, floor
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_ceil.x, coord_ceil.y, coord_floor.z),
        weights[6] * one_axis_velocity * MULTIPLIER);
    
    // ceil, ceil, ceil
    AtomicAdd(rwTex, rwTexSize,
        uint3(coord_ceil.x, coord_ceil.y, coord_ceil.z),
        weights[7] * one_axis_velocity * MULTIPLIER);
}

void TrilinearBackwardAdvection(uniform RWTexture3D<int> rwTex, uniform uint3 rwTexSize, uniform RWTexture3D<int> velocity_tex,
    uint3 target_id, uint3 coord_floor, uint3 coord_ceil, float weights[8])
{
    float velocity = 0;
    // floor, floor, floor
    velocity = IntToFloat(velocity_tex[uint3(coord_floor.x, coord_floor.y, coord_floor.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[0] * velocity * MULTIPLIER);
    
    // floor, floor, ceil
    velocity = IntToFloat(velocity_tex[uint3(coord_floor.x, coord_floor.y, coord_ceil.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[1] * velocity * MULTIPLIER);
    
    // floor, ceil, floor
    velocity = IntToFloat(velocity_tex[uint3(coord_floor.x, coord_ceil.y, coord_floor.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[2] * velocity * MULTIPLIER);
    
    // floor, ceil, ceil
    velocity = IntToFloat(velocity_tex[uint3(coord_floor.x, coord_ceil.y, coord_ceil.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[3] * velocity * MULTIPLIER);
    
    // ceil, floor, floor
    velocity = IntToFloat(velocity_tex[uint3(coord_ceil.x, coord_floor.y, coord_floor.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[4] * velocity * MULTIPLIER);
    
    // ceil, floor, ceil
    velocity = IntToFloat(velocity_tex[uint3(coord_ceil.x, coord_floor.y, coord_ceil.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[5] * velocity * MULTIPLIER);
    
    // ceil, ceil, floor
    velocity = IntToFloat(velocity_tex[uint3(coord_ceil.x, coord_ceil.y, coord_floor.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[6] * velocity * MULTIPLIER);
    
    // ceil, ceil, ceil
    velocity = IntToFloat(velocity_tex[uint3(coord_ceil.x, coord_ceil.y, coord_ceil.z)]);
    AtomicAdd(rwTex, rwTexSize, target_id, weights[7] * velocity * MULTIPLIER);
}

[numthreads(8,4,8)]
void AdvectionCleanUp(uint3 id : SV_DispatchThreadID)
{
    _WindTexturePrevPrevX[id] = 0;
    _WindTexturePrevPrevY[id] = 0;
    _WindTexturePrevPrevZ[id] = 0;
}

[numthreads(8,4,8)]
void ForwardAdvectionXYZ (uint3 id : SV_DispatchThreadID)
{
    const float velocity_x = IntToFloat(_WindTexturePrevX[id]);
    const float velocity_y = IntToFloat(_WindTexturePrevY[id]);
    const float velocity_z = IntToFloat(_WindTexturePrevZ[id]);
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    
    float3 target_id = (float3)id + float3(velocity_x, velocity_y, velocity_z) * a;
    
    target_id.x = clamp(target_id.x, 0, _WindVolumeTextureSize.x - 1);
    target_id.y = clamp(target_id.y, 0, _WindVolumeTextureSize.y - 1);
    target_id.z = clamp(target_id.z, 0, _WindVolumeTextureSize.z - 1);
    
    const uint floor_id_x = uint(target_id.x);
    const uint ceil_id_x = floor_id_x + 1;
    const float ceil_weight_x = (target_id.x - floor_id_x) / (ceil_id_x - floor_id_x);
    const float floor_weight_x = 1 - ceil_weight_x;
    
    const uint floor_id_y = uint(target_id.y);
    const uint ceil_id_y = floor_id_y + 1;
    const float ceil_weight_y = (target_id.y - floor_id_y) / (ceil_id_y - floor_id_y);
    const float floor_weight_y = 1 - ceil_weight_y;
    
    const uint floor_id_z = uint(target_id.z);
    const uint ceil_id_z = floor_id_z + 1;
    const float ceil_weight_z = (target_id.z - floor_id_z) / (ceil_id_z - floor_id_z);
    const float floor_weight_z = 1 - ceil_weight_z;

    float weights[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    CalculateWeights(weights,
        float3(floor_weight_x, floor_weight_y, floor_weight_z),
        float3(ceil_weight_x, ceil_weight_y, ceil_weight_z));

    TrilinearForwardAdvection(_WindTexturePrevPrevX, _WindVolumeTextureSize,
        uint3(floor_id_x, floor_id_y, floor_id_z),
        uint3(ceil_id_x, ceil_id_y, ceil_id_z),
        weights, velocity_x);
    
    TrilinearForwardAdvection(_WindTexturePrevPrevY, _WindVolumeTextureSize,
    uint3(floor_id_x, floor_id_y, floor_id_z),
    uint3(ceil_id_x, ceil_id_y, ceil_id_z),
        weights, velocity_y);
    
    TrilinearForwardAdvection(_WindTexturePrevPrevZ, _WindVolumeTextureSize,
    uint3(floor_id_x, floor_id_y, floor_id_z),
    uint3(ceil_id_x, ceil_id_y, ceil_id_z),
        weights, velocity_z);
}

[numthreads(8,4,8)]
void BackwardAdvectionXYZ (uint3 id : SV_DispatchThreadID)
{
    const float velocity_x = IntToFloat(_WindTexturePrevX[id]);
    const float velocity_y = IntToFloat(_WindTexturePrevY[id]);
    const float velocity_z = IntToFloat(_WindTexturePrevZ[id]);
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    
    float3 target_id = (float3)id - float3(velocity_x, velocity_y, velocity_z) * a;
    
    target_id.x = clamp(target_id.x, 0, _WindVolumeTextureSize.x - 1);
    target_id.y = clamp(target_id.y, 0, _WindVolumeTextureSize.y - 1);
    target_id.z = clamp(target_id.z, 0, _WindVolumeTextureSize.z - 1);
    
    const uint floor_id_x = uint(target_id.x);
    const uint ceil_id_x = floor_id_x + 1;
    const float ceil_weight_x = (target_id.x - floor_id_x) / (ceil_id_x - floor_id_x);
    const float floor_weight_x = 1 - ceil_weight_x;
    
    const uint floor_id_y = uint(target_id.y);
    const uint ceil_id_y = floor_id_y + 1;
    const float ceil_weight_y = (target_id.y - floor_id_y) / (ceil_id_y - floor_id_y);
    const float floor_weight_y = 1 - ceil_weight_y;
    
    const uint floor_id_z = uint(target_id.z);
    const uint ceil_id_z = floor_id_z + 1;
    const float ceil_weight_z = (target_id.z - floor_id_z) / (ceil_id_z - floor_id_z);
    const float floor_weight_z = 1 - ceil_weight_z;

    float weights[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    CalculateWeights(weights,
        float3(floor_weight_x, floor_weight_y, floor_weight_z),
        float3(ceil_weight_x, ceil_weight_y, ceil_weight_z));

    TrilinearBackwardAdvection(_WindTexturePrevPrevX, _WindVolumeTextureSize, _WindTexturePrevX, id,
    uint3(floor_id_x, floor_id_y, floor_id_z),
    uint3(ceil_id_x, ceil_id_y, ceil_id_z), weights);
    
    TrilinearBackwardAdvection(_WindTexturePrevPrevY, _WindVolumeTextureSize, _WindTexturePrevY, id,
    uint3(floor_id_x, floor_id_y, floor_id_z),
    uint3(ceil_id_x, ceil_id_y, ceil_id_z), weights);
    
    TrilinearBackwardAdvection(_WindTexturePrevPrevZ, _WindVolumeTextureSize, _WindTexturePrevZ, id,
    uint3(floor_id_x, floor_id_y, floor_id_z),
    uint3(ceil_id_x, ceil_id_y, ceil_id_z), weights);
}

[numthreads(8,4,8)]
void ForwardAdvectionX (uint3 id : SV_DispatchThreadID)
{
    // Directly add up the values in int32 tex
    const float velocity_x = IntToFloat(_WindTexturePrevX[id]);
    const float velocity_y = IntToFloat(_WindTexturePrevY[id]);
    const float velocity_z = IntToFloat(_WindTexturePrevZ[id]);
    //const float a = _DeltaTime * _WindVolumeTextureSize.x * _WindAdvectionIntensity;
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    const float target_id_x = (float)id.x + velocity_x * a;
    if (target_id_x < (float)_WindVolumeTextureSize.x - 1 && target_id_x > 0) // within the boundary
    {
        // calculate the floor and ceil of the coordinate
        float floor_id_x = floor(target_id_x);
        float ceil_id_x = ceil(target_id_x) + 0.001f; // prevent divide by zero occasion
        const float floor_weight = (target_id_x - floor_id_x) / (ceil_id_x - floor_id_x);
        // X Velocity Advection
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, uint3(floor_id_x, id.y, id.z), floor_weight * velocity_x * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, uint3(ceil_id_x, id.y, id.z), (1 - floor_weight) * velocity_x * MULTIPLIER);
        // Y Velocity Advection
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, uint3(floor_id_x, id.y, id.z), floor_weight * velocity_y * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, uint3(ceil_id_x, id.y, id.z), (1 - floor_weight) * velocity_y * MULTIPLIER);
        // Z Velocity Advection
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, uint3(floor_id_x, id.y, id.z), floor_weight * velocity_z * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, uint3(ceil_id_x, id.y, id.z), (1 - floor_weight) * velocity_z * MULTIPLIER);
    }
    // without the boundary? no further modification...
}

[numthreads(8,4,8)]
void ForwardAdvectionY (uint3 id : SV_DispatchThreadID)
{
    const float velocity_x = IntToFloat(_WindTexturePrevX[id]);
    const float velocity_y = IntToFloat(_WindTexturePrevY[id]);
    const float velocity_z = IntToFloat(_WindTexturePrevZ[id]);
    // const float a = _DeltaTime * _WindVolumeTextureSize.y * _WindAdvectionIntensity;
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    const float target_id_y = (float)id.y + velocity_y * a;
    if (target_id_y < (float)_WindVolumeTextureSize.y - 1 && target_id_y > 0) // within the boundary
    {
        // calculate the floor and ceil of the coordinate
        float floor_id_y = floor(target_id_y);
        float ceil_id_y = ceil(target_id_y) + 0.001f; // prevent divide by zero occasion
        const float floor_weight = (target_id_y - floor_id_y) / (ceil_id_y - floor_id_y);
        // X Velocity Advection
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, uint3(id.x, floor_id_y, id.z), floor_weight * velocity_x * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, uint3(id.x, ceil_id_y, id.z), (1 - floor_weight) * velocity_x * MULTIPLIER);
        // Y Velocity Advection
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, uint3(id.x, floor_id_y, id.z), floor_weight * velocity_y * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, uint3(id.x, ceil_id_y, id.z), (1 - floor_weight) * velocity_y * MULTIPLIER);
        // Z Velocity Advection
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, uint3(id.x, floor_id_y, id.z), floor_weight * velocity_z * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, uint3(id.x, ceil_id_y, id.z), (1 - floor_weight) * velocity_z * MULTIPLIER);
    }
}

[numthreads(8,4,8)]
void ForwardAdvectionZ (uint3 id : SV_DispatchThreadID)
{
    const float velocity_x = IntToFloat(_WindTexturePrevX[id]);
    const float velocity_y = IntToFloat(_WindTexturePrevY[id]);
    const float velocity_z = IntToFloat(_WindTexturePrevZ[id]);
    // const float a = _DeltaTime * _WindVolumeTextureSize.z * _WindAdvectionIntensity;
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    const float target_id_z = (float)id.z + velocity_z * a;
    if (target_id_z < (float)_WindVolumeTextureSize.z - 1 && target_id_z > 0) // within the boundary
    {
        // calculate the floor and ceil of the coordinate
        float floor_id_z = floor(target_id_z);
        float ceil_id_z = ceil(target_id_z) + 0.001f; // prevent divide by zero occasion
        const float floor_weight = (target_id_z - floor_id_z) / (ceil_id_z - floor_id_z);
        // X Velocity Advection
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, uint3(id.x, id.y, floor_id_z), floor_weight * velocity_x * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, uint3(id.x, id.y, ceil_id_z), (1 - floor_weight) * velocity_x * MULTIPLIER);
        // Y Velocity Advection
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, uint3(id.x, id.y, floor_id_z), floor_weight * velocity_y * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, uint3(id.x, id.y, ceil_id_z), (1 - floor_weight) * velocity_y * MULTIPLIER);
        // Z Velocity Advection
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, uint3(id.x, id.y, floor_id_z), floor_weight * velocity_z * MULTIPLIER);
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, uint3(id.x, id.y, ceil_id_z), (1 - floor_weight) * velocity_z * MULTIPLIER);
    }
}

[numthreads(8,4,8)]
void BackwardAdvectionX (uint3 id : SV_DispatchThreadID)
{
    const float velocity_x = IntToFloat(_WindTexturePrevX[id]);
    // const float a = _DeltaTime * _WindVolumeTextureSize.x * _WindAdvectionIntensity;
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    const float target_id_x = (float)id.x - velocity_x * a; // backtrace the target velocity
    if (target_id_x < (float)_WindVolumeTextureSize.x - 1 && target_id_x > 0) // within the boundary
    {
        // calculate the floor and ceil of the coordinate
        float floor_id_x = floor(target_id_x);
        float ceil_id_x = ceil(target_id_x) + 0.001f; // prevent divide by zero occasion
        const float floor_weight = (target_id_x - floor_id_x) / (ceil_id_x - floor_id_x);
        
        const float velocity_x_ceil = IntToFloat(_WindTexturePrevX[uint3(ceil_id_x, id.y, id.z)]);
        const float velocity_x_floor = IntToFloat(_WindTexturePrevX[uint3(floor_id_x, id.y, id.z)]);
        const float velocity_y_ceil = IntToFloat(_WindTexturePrevY[uint3(ceil_id_x, id.y, id.z)]);
        const float velocity_y_floor = IntToFloat(_WindTexturePrevY[uint3(floor_id_x, id.y, id.z)]);
        const float velocity_z_ceil = IntToFloat(_WindTexturePrevZ[uint3(ceil_id_x, id.y, id.z)]);
        const float velocity_z_floor = IntToFloat(_WindTexturePrevZ[uint3(floor_id_x, id.y, id.z)]);
        
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, id,  (floor_weight * MULTIPLIER * velocity_x_floor));
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_x_ceil));

        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, id,  (floor_weight * MULTIPLIER * velocity_y_floor));
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_y_ceil));

        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, id,  (floor_weight * MULTIPLIER * velocity_z_floor));
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_z_ceil));
    }
}

[numthreads(8,4,8)]
void BackwardAdvectionY (uint3 id : SV_DispatchThreadID)
{
    const float velocity_y = IntToFloat(_WindTexturePrevY[id]);
    // const float a = _DeltaTime * _WindVolumeTextureSize.y * _WindAdvectionIntensity;
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    const float target_id_y = (float)id.y - velocity_y * a; // backtrace the target velocity
    if (target_id_y < (float)_WindVolumeTextureSize.y - 1 && target_id_y > 0) // within the boundary
    {
        // calculate the floor and ceil of the coordinate
        float floor_id_y = floor(target_id_y);
        float ceil_id_y = ceil(target_id_y) + 0.001f; // prevent divide by zero occasion
        const float floor_weight = (target_id_y - floor_id_y) / (ceil_id_y - floor_id_y);
        
        const float velocity_x_ceil = IntToFloat(_WindTexturePrevX[uint3(id.x, ceil_id_y, id.z)]);
        const float velocity_x_floor = IntToFloat(_WindTexturePrevX[uint3(id.x, floor_id_y, id.z)]);
        const float velocity_y_ceil = IntToFloat(_WindTexturePrevY[uint3(id.x, ceil_id_y, id.z)]);
        const float velocity_y_floor = IntToFloat(_WindTexturePrevY[uint3(id.x, floor_id_y, id.z)]);
        const float velocity_z_ceil = IntToFloat(_WindTexturePrevZ[uint3(id.x, ceil_id_y, id.z)]);
        const float velocity_z_floor = IntToFloat(_WindTexturePrevZ[uint3(id.x, floor_id_y, id.z)]);

        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, id, (floor_weight * MULTIPLIER * velocity_x_floor));
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_x_ceil));
        
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, id, (floor_weight * MULTIPLIER * velocity_y_floor));
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_y_ceil));

        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, id, (floor_weight * MULTIPLIER * velocity_z_floor));
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_z_ceil));
    }
}

[numthreads(8,4,8)]
void BackwardAdvectionZ (uint3 id : SV_DispatchThreadID)
{
    const float velocity_z = IntToFloat(_WindTexturePrevZ[id]);
    // const float a = _DeltaTime * _WindVolumeTextureSize.z * _WindAdvectionIntensity;
    const float a = unity_DeltaTime[0] * _WindAdvectionIntensity;
    const float target_id_z = (float)id.z - velocity_z * a; // backtrace the target velocity
    if (target_id_z < (float)_WindVolumeTextureSize.z - 1 && target_id_z > 0) // within the boundary
    {
        // calculate the floor and ceil of the coordinate
        float floor_id_z = floor(target_id_z);
        float ceil_id_z = ceil(target_id_z) + 0.001f; // prevent divide by zero occasion
        const float floor_weight = (target_id_z - floor_id_z) / (ceil_id_z - floor_id_z);

        const float velocity_x_ceil = IntToFloat(_WindTexturePrevX[uint3(id.x, id.y, ceil_id_z)]);
        const float velocity_x_floor = IntToFloat(_WindTexturePrevX[uint3(id.x, id.y, floor_id_z)]);
        const float velocity_y_ceil = IntToFloat(_WindTexturePrevY[uint3(id.x, id.y, ceil_id_z)]);
        const float velocity_y_floor = IntToFloat(_WindTexturePrevY[uint3(id.x, id.y, floor_id_z)]);
        const float velocity_z_ceil = IntToFloat(_WindTexturePrevZ[uint3(id.x, id.y, ceil_id_z)]);
        const float velocity_z_floor = IntToFloat(_WindTexturePrevZ[uint3(id.x, id.y, floor_id_z)]);

        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, id,  (floor_weight * MULTIPLIER * velocity_x_floor));
        AtomicAdd(_WindTexturePrevPrevX, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_x_ceil));
        
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, id,  (floor_weight * MULTIPLIER * velocity_y_floor));
        AtomicAdd(_WindTexturePrevPrevY, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_y_ceil));
        
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, id,  (floor_weight * MULTIPLIER * velocity_z_floor));
        AtomicAdd(_WindTexturePrevPrevZ, _WindVolumeTextureSize, id, ((1 - floor_weight) * MULTIPLIER * velocity_z_ceil));
    }
}
