// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define WIND_CALCULATION
#define BOX_WINDS
#define CYLINDER_WINDS
#define SPHERE_WINDS

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

// Wind Volume XYZ Axis separated
#define FXDPT_SIZE (1 << 16) // negative 16, positive 16 => int32 texture
RWTexture3D<int> _GlobalWindVolume3DX;
RWTexture3D<int> _GlobalWindVolume3DY;
RWTexture3D<int> _GlobalWindVolume3DZ;

float4 _WindVolumeCenterPosition;
float _WindVolumeVoxelSize;

#ifdef WIND_CALCULATION

struct FixedCalculationType
{
    float3 fixedWindVelocityWS;
};
StructuredBuffer<FixedCalculationType> _fixedCalculationParams;

struct PointBasedCalculationType
{
    // xyz center point position (world space), w max wind speed 
    float4 pointBasedCalculationDataAlpha;
    // e^(-decay * distance)
    float distanceDecayInfluence;
};
StructuredBuffer<PointBasedCalculationType> _pointBasedCalculationParams;

struct AxisBasedCalculationType
{
    // xyz center point position (world space), w axis distance decay influence
    float4 axisBasedCalculationDataAlpha;
    // xyz axis direction (world space), w axis rotation velocity multiplier
    float4 axisBasedCalculationDataBeta;
};
StructuredBuffer<AxisBasedCalculationType> _axisBasedCalculationParams;

#endif

float3 FixedCalculation(uint index)
{
    return _fixedCalculationParams[index].fixedWindVelocityWS;
}

float3 PointBasedCalculation(uint index, float3 positionWS)
{
    float4 dataAlpha = _pointBasedCalculationParams[index].pointBasedCalculationDataAlpha;
    float decayInfluence = _pointBasedCalculationParams[index].distanceDecayInfluence;
    float d = distance(dataAlpha.xyz, positionWS);
    float3 direction = (dataAlpha.xyz - positionWS) / max(d, 0.0001f);
    float speed = exp(-decayInfluence * d) * dataAlpha.w;
    return direction * speed;
}

void Unity_RotateAboutAxis_Radians_float(float3 In, float3 Axis, float Rotation, out float3 Out)
{
    float s = sin(Rotation);
    float c = cos(Rotation);
    float one_minus_c = 1.0 - c;

    Axis = normalize(Axis);
    float3x3 rot_mat = 
    {   one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s,
        one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s,
        one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c
    };
    Out = mul(rot_mat,  In);
}

float3 AxisBasedCalculation(uint index, float3 positionWS)
{
    float4 dataAlpha = _axisBasedCalculationParams[index].axisBasedCalculationDataAlpha;
    float4 dataBeta = _axisBasedCalculationParams[index].axisBasedCalculationDataBeta;
    
    const float3 axis_point = dataAlpha.xyz;
    const float3 axis_direction = dataBeta.xyz;

    const float3 axis_point_to_voxel = positionWS - axis_point;
    const float3 axis_direction_vector = axis_direction * dot(axis_point_to_voxel, axis_direction);
    const float3 perpendicular_vector = axis_point_to_voxel - axis_direction_vector;
    float rotate_rad = PI * _Time[0] * 4;
    float3 rotate_perpendicular_vector;
    //Unity_RotateAboutAxis_Radians_float(perpendicular_vector, axis_direction, rotate_rad, rotate_perpendicular_vector);
    
    float d = length(perpendicular_vector);
    const float3 rotate_perpendicular_direction = perpendicular_vector / max(d, 0.0001f);
    float speed = exp(-dataAlpha.w * d) * dataBeta.w;
    float3 vortex_direction = cross(rotate_perpendicular_direction, axis_direction);
    
    return vortex_direction * speed;
}

#ifdef BOX_WINDS
struct BoxWind
{
    uint calculationType;
    uint calculationBufferIndex;
    float3 extendsLocal;
    float4x4 worldToLocal;
};
StructuredBuffer<BoxWind> _boxWindContributors;
int _boxWindCount;
#endif

#ifdef CYLINDER_WINDS
struct CylinderWind
{
    uint calculationType;
    uint calculationBufferIndex;
    float2 extendsLocal; // x for radius squared, y for height
    float4x4 worldToLocal;
};
StructuredBuffer<CylinderWind> _cylinderWindContributors;
int _cylinderWindCount;
#endif

#ifdef SPHERE_WINDS

struct SphereWind
{
    uint calculationType;
    uint calculationBufferIndex;
    float3 centerPositionWorldSpace;
    float extendSquared; // radius squared
};
StructuredBuffer<SphereWind> _sphereWindContributors;
int _sphereWindCount;

#endif

float hash( float n ) { return frac(sin(n)*753.5453123); }
// parameter noise
float noisep(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f*f*(3.0-2.0*f);
	
    float n = p.x + p.y*157.0 + 113.0*p.z;
    return lerp(lerp(lerp( hash(n+  0.0), hash(n+  1.0),f.x),
                   lerp( hash(n+157.0), hash(n+158.0),f.x),f.y),
               lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                   lerp( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}

float ScrollNoise(float3 pos, float speed, float scale, float3 dir, float amount, float bias = 0.0, float mult = 1.0)
{
    float time = _Time.y * speed;
    float noiseScale = scale;
    float3 noiseScroll = dir * time;
    float3 q = pos - noiseScroll;
    q *= scale;
    float f = 0;
    f = 0.5 * noisep(q);
    // scroll the next octave in the opposite direction to get some morphing instead of just scrolling
    q += noiseScroll * scale;
    q = q * 2.01;
    f += 0.25 * noisep(q);

    f += bias;
    f *= mult;

    f = max(f, 0.0);
    return lerp(1.0, f, amount);
}

float3 GlobalWindNoise3D(float3 pos, float scrollSpeed, float3 frequency, float3 scrollDir, float intensity = 1.0)
{
    float3 noiseOffset = float3(725, 63, 886);
    float time = _Time.y * scrollSpeed;
    float3 noiseScroll = scrollDir * time;
    float3 newPosition = pos - noiseScroll;
    newPosition *= frequency;
    
    // three noise values calculation, 2 octaves, 0.75 - 1.333333
    float f1 = 0;
    f1 = 0.5 * noisep(newPosition);
    float f2 = 0;
    f2 = 0.5 * noisep(newPosition + noiseOffset);
    float f3 = 0;
    f3 = 0.5 * noisep(newPosition - noiseOffset);
    
    newPosition += noiseScroll * frequency;
    newPosition *= 2.01;
    noiseOffset *= 2.01;
    f1 += 0.25 * noisep(newPosition);
    f2 += 0.25 * noisep(newPosition + noiseOffset);
    f3 += 0.25 * noisep(newPosition - noiseOffset);

    float3 wind = (float3(f1, f2, f3) - 0.5) * 2;
    wind *= 1.333333 * intensity;
    return wind;
}

#ifdef BOX_WINDS
float3 BoxWinds(float3 positionWS)
{
    float boxWindIntensity = 0;
    float3 windCalculationResult = 0;
    for(int i = 0; i < _boxWindCount; i++)
    {
        // get a vector from center to current voxel position in local space
        float4 localVoxelPosition = mul(_boxWindContributors[i].worldToLocal, float4(positionWS, 1));
        float3 extendsLocal = _boxWindContributors[i].extendsLocal;
        // compare the local position with extends
        float withInX = step(abs(localVoxelPosition.x), extendsLocal.x/2); // step (y,x) 1 if the x parameter is greater than or equal to the y parameter; otherwise, 0.
        float withInY = step(abs(localVoxelPosition.y), extendsLocal.y/2);
        float withInZ = step(abs(localVoxelPosition.z), extendsLocal.z/2);
        
        boxWindIntensity = withInX * withInY * withInZ;
        
        // get the parameters needed to calculate wind directions and intensities
        switch (_boxWindContributors[i].calculationType)
        {
            case 0:
                windCalculationResult += FixedCalculation(_boxWindContributors[i].calculationBufferIndex);
                break;
            case 1:
                windCalculationResult += PointBasedCalculation(_boxWindContributors[i].calculationBufferIndex, positionWS);
                break;
            case 2:
                windCalculationResult += AxisBasedCalculation(_boxWindContributors[i].calculationBufferIndex, positionWS);
                break;
            default:
                windCalculationResult += 0;
                break;
        }
    }
    return windCalculationResult * boxWindIntensity;
}
#endif

#ifdef CYLINDER_WINDS
float3 CylinderWinds(float3 positionWS)
{
    float cylinderWindIntensity = 0;
    float3 windCalculationResult = 0;
    for(int i = 0; i < _cylinderWindCount; i++)
    {
        float4 localVoxelPosition = mul(_cylinderWindContributors[i].worldToLocal, float4(positionWS, 1));
        float2 extendsLocal = _cylinderWindContributors[i].extendsLocal;
        // compare the local position with extends
        const float distanceSquared = max(Length2(localVoxelPosition.xyz), 0.0f);
        float withInX = step(distanceSquared, extendsLocal.x); // step (y,x) 1 if the x parameter is greater than or equal to the y parameter; otherwise, 0.
        float withInY = step(abs(localVoxelPosition.y), extendsLocal.y/2);

        cylinderWindIntensity = withInX * withInY;
        
        // get the parameters needed to calculate wind directions and intensities
        switch (_cylinderWindContributors[i].calculationType)
        {
        case 0:
            windCalculationResult += FixedCalculation(_cylinderWindContributors[i].calculationBufferIndex);
            break;
        case 1:
            windCalculationResult += PointBasedCalculation(_cylinderWindContributors[i].calculationBufferIndex, positionWS);
            break;
        case 2:
            windCalculationResult += AxisBasedCalculation(_cylinderWindContributors[i].calculationBufferIndex, positionWS);
            break;
        default:
            windCalculationResult += 0;
            break;
        }
    }
    return windCalculationResult * cylinderWindIntensity;
}
#endif

#ifdef SPHERE_WINDS

float3 SphereWinds(float3 positionWS)
{
    float sphereWindIntensity = 0;
    float3 windCalculationResult = 0;
    for(int i = 0; i < _sphereWindCount; i++)
    {
        float3 localVoxelPosition = positionWS - _sphereWindContributors[i].centerPositionWorldSpace;
        // compare the local position with radius
        const float distanceSquared = max(Length2(localVoxelPosition), 0.0f);
        float withInX = step(distanceSquared, _sphereWindContributors[i].extendSquared); // step (y,x) 1 if the x parameter is greater than or equal to the y parameter; otherwise, 0.

        sphereWindIntensity = withInX;
        
        // get the parameters needed to calculate wind directions and intensities
        switch (_sphereWindContributors[i].calculationType)
        {
        case 0:
            windCalculationResult += FixedCalculation(_sphereWindContributors[i].calculationBufferIndex);
            break;
        case 1:
            windCalculationResult += PointBasedCalculation(_sphereWindContributors[i].calculationBufferIndex, positionWS);
            break;
        case 2:
            windCalculationResult += AxisBasedCalculation(_sphereWindContributors[i].calculationBufferIndex, positionWS);
            break;
        default:
            windCalculationResult += 0;
            break;
        }
    }
    return windCalculationResult * sphereWindIntensity;
}

#endif

[numthreads(8,4,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 positionWS = 0;
    positionWS = (float3(id) - float3(15.5, 7.5, 15.5)) * _WindVolumeVoxelSize + _WindVolumeCenterPosition.xyz;
    
    float3 windWithIntensity = 0;

    #ifdef BOX_WINDS
    windWithIntensity += BoxWinds(positionWS);
    #endif

    #ifdef CYLINDER_WINDS
    windWithIntensity += CylinderWinds(positionWS);
    #endif

    #ifdef SPHERE_WINDS
    windWithIntensity += SphereWinds(positionWS);
    #endif
    
    // Output, rgb direction, a magnitude (speed)
    float4 output;
    //float mag = length(windWithIntensity.xyz);
    //float3 dir = windWithIntensity/mag;
    output.rgb = windWithIntensity;
    output.a = 0; // not used
    _GlobalWindVolume3DX[id] += (int)(output.x * FXDPT_SIZE);
    _GlobalWindVolume3DY[id] += (int)(output.y * FXDPT_SIZE);
    _GlobalWindVolume3DZ[id] += (int)(output.z * FXDPT_SIZE);
}
