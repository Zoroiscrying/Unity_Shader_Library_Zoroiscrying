// Each #kernel tells which function to compile; you can have many kernels
#pragma multi_compile_local __ TEXTURE_NOISE FUNCTION_NOISE
#pragma kernel CSMain
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

// Wind Volume
RWTexture3D<float4> _WindDirectionIntensityVolume;
float4 _WindNoiseScrollDirAndSpeed;
float3 _WindVolumeCenterPosition;
float _WindVolumeVoxelSize;
// Custom Parameters
Texture2D _Noise;
SamplerState sampler_Noise;
half4 _AmbientWind;
float _NoiseWindIntensity;
float3 _WindNoisePosFrequency;
float3 _WindNoisePosOffset;

#ifdef BOX_WINDS
struct BoxWind
{
    float3 center;
    float3 extends;
    float3x3 rotation;
};
StructuredBuffer<BoxWind> _boxWindContributors;
float _boxWindCount;
#endif

#ifdef CYLINDER_WINDS
struct CylinderWind
{
    
};
StructuredBuffer<CylinderWind> _cylinderWindContributors;
float _cylinderWindCount;
#endif

float hash( float n ) { return frac(sin(n)*753.5453123); }
// parameter noise
float noisep(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f*f*(3.0-2.0*f);
	
    float n = p.x + p.y*157.0 + 113.0*p.z;
    return lerp(lerp(lerp( hash(n+  0.0), hash(n+  1.0),f.x),
                   lerp( hash(n+157.0), hash(n+158.0),f.x),f.y),
               lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                   lerp( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}
// texture noise
float noise(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float2 uv = (p.xy + float2(37.0,17.0) * p.z) + f.xy;
    float2 rg = _Noise.SampleLevel(sampler_Noise, (uv + 0.5) / 256.0, 0).yx;
    return -1.0 + 2.0 * lerp(rg.x, rg.y, f.z);
}

float ScrollNoise(float3 pos, float speed, float scale, float3 dir, float amount, float bias = 0.0, float mult = 1.0)
{
    float time = _Time * speed;
    float noiseScale = scale;
    float3 noiseScroll = dir * time;
    float3 q = pos - noiseScroll;
    q *= scale;
    float f = 0;
    f = 0.5 * noisep(q);
    // scroll the next octave in the opposite direction to get some morphing instead of just scrolling
    q += noiseScroll * scale;
    q = q * 2.01;
    f += 0.25 * noisep(q);

    f += bias;
    f *= mult;

    f = max(f, 0.0);
    return lerp(1.0, f, amount);
}

float3 GlobalWindNoise3D(float3 pos, float scrollSpeed, float3 frequency, float3 scrollDir, float intensity = 1.0)
{
    float3 noiseOffset = float3(725, 63, 886);
    float time = _Time.y * scrollSpeed;
    float3 noiseScroll = scrollDir * time;
    float3 newPosition = pos - noiseScroll;
    newPosition *= frequency;
    
    // three noise values calculation, 2 octaves, 0.75 - 1.333333
    float f1 = 0;
    f1 = 0.5 * noisep(newPosition);
    float f2 = 0;
    f2 = 0.5 * noisep(newPosition + noiseOffset);
    float f3 = 0;
    f3 = 0.5 * noisep(newPosition - noiseOffset);
    
    newPosition += noiseScroll * frequency;
    newPosition *= 2.01;
    noiseOffset *= 2.01;
    f1 += 0.25 * noisep(newPosition);
    f2 += 0.25 * noisep(newPosition + noiseOffset);
    f3 += 0.25 * noisep(newPosition - noiseOffset);

    float3 wind = (float3(f1, f2, f3) - 0.5) * 2;
    wind *= 1.333333 * intensity;
    return wind;
}

// Calculate the constant wind from current position
float ConstantWind3D(float3 positionWS)
{
    return 0;
}

#ifdef BOX_WINDS
float3 BoxWinds(float3 positionWS)
{
    float3 boxWindVector = 0;
    for(int i = 0; i < _boxWindCount; i++)
    {
        // get the parameters needed to calculate wind directions and intensities
    }
    return boxWindVector;
}
#endif

#ifdef CYLINDER_WINDS
float3 CylinderWinds(float3 positionWS)
{
    float3 cylinderWindVector = 0;
    for(int i = 0; i < _cylinderWindCount; i++)
    {
        // get the parameters needed to calculate wind directions and intensities
    }
    return cylinderWindVector;
}
#endif

[numthreads(8,4,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float4 directionAndIntensity = _AmbientWind;
    float3 windWithIntensity = directionAndIntensity.xyz * directionAndIntensity.w;
    
    float2 uv = float2(id.x/63.0, id.y/31.0);
    float z = id.z/63.0;
    float3 positionWS = _WindVolumeCenterPosition + (float3(id) - float3(31.5, 15.5, 31.5)) * _WindVolumeVoxelSize;
    
    #if FUNCTION_NOISE
    windWithIntensity += GlobalWindNoise3D(positionWS,
                    _WindNoiseScrollDirAndSpeed.a,
                    _WindNoisePosFrequency,
                    _WindNoiseScrollDirAndSpeed.xyz, _NoiseWindIntensity);
    #elif TEXTURE_NOISE
    // do nothing
    #endif

    #ifdef BOX_WINDS
    windWithIntensity += BoxWinds(positionWS);
    #endif

    #ifdef CYLINDER_WINDS
    windWithIntensity += CylinderWinds(positionWS);
    #endif
    
    // Output, rgb direction, a magnitude (speed)
    float4 output;
    float mag = length(windWithIntensity.xyz);
    float3 dir = windWithIntensity/mag;
    output.rgb = dir;
    output.a = mag;
    _WindDirectionIntensityVolume[id] = output;
}
