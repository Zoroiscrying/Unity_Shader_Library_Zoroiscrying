// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "DeformableSnowAndSandShaderUtility.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//uniform RWTexture2D<uint> SnowDepressionTexture;
//// the center height of the depression space
//float CurrentMinimumHeightWorldSpace;
//float SnowTextureWorldCenterX;
//float SnowTextureWorldCenterZ;
//// texture resolution and world space size
//uint SnowTextureResolution;
//float SnowTextureSizeWorldSpace;

// #define FXDPT_SIZE (1 << 8)
// 
// // depression height takes up 16 bits (uint), excluding the left most one, range from 0 to 1<<15-1
// #define DEPRESSION_MAX 0xffff
// // foot height takes up 10 bits (uint), range from 0 to 1<<10 - 1 (right now we're using all 16 bits)
// #define FOOT_HEIGHT_MAX 0xffff
// // timer takes up 6 bits (uint), range from 0 to 1<<6 - 1
// #define TIMER_MAX (1 << 6) - 1

float hash( float n ) { return frac(sin(n)*753.5453123); }
// parameter noise
float noise_p(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f*f*(3.0-2.0*f);
	
    float n = p.x + p.y*157.0 + 113.0*p.z;
    return lerp(lerp(lerp( hash(n+  0.0), hash(n+  1.0),f.x),
                   lerp( hash(n+157.0), hash(n+158.0),f.x),f.y),
               lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
                   lerp( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}

float ScrollNoise(float3 pos, float speed, float scale, float3 dir, float amount, float bias = 0.0, float mult = 1.0)
{
    float time = _Time.y * speed;
    float noiseScale = scale;
    float3 noiseScroll = dir * time;
    float3 q = pos - noiseScroll;
    q *= scale;
    float f = 0;
    f = 0.5 * noise_p(q);
    // scroll the next octave in the opposite direction to get some morphing instead of just scrolling
    q += noiseScroll * scale;
    q = q * 2.01;
    f += 0.25 * noise_p(q);

    f += bias;
    f *= mult;

    f = max(f, 0.0);
    return lerp(1.0, f, amount);
}

float UniformSnowFillRate;
float DeltaTime;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float depression_height_ws;
    float foot_height_ws;
    float timer;
    
    ExtractDepressionDataFromInt32(SnowDepressionTexture[id.xy], depression_height_ws, foot_height_ws, timer);
    depression_height_ws += unity_DeltaTime.z * 0.25f;
    foot_height_ws += unity_DeltaTime.z * 0.25f;
    
    SnowDepressionTexture[id.xy] = EmbedSnowDepressionDataToUInt32(
        depression_height_ws - CurrentMinimumHeightWorldSpace,
        foot_height_ws - CurrentMinimumHeightWorldSpace,
        timer);
}
